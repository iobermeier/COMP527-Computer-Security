from typing import List, Any, NamedTuple

from .elgamal import ElGamalCiphertext
from .group import (
    ElementModQ,
    ElementModP,
    g_pow_p,
    mult_p,
    pow_p,
    a_minus_b_q,
    a_plus_bc_q,
    add_q,
    negate_q,
    int_to_q,
    int_to_p,
    G_MOD_P,
    div_p,
)
from .hash import hash_elems
from .logs import log_warning
from .nonces import Nonces


class GenericChaumPedersenProof(NamedTuple):
    """
    General-purpose Chaum-Pedersen proof object, demonstrating that the prover knows the exponent
    x for two tuples (g, g^x) and (h, h^x). This is used as a component in other proofs.
    """

    a: ElementModP
    """a = g^w"""

    b: ElementModP
    """b = h^w"""

    c: ElementModQ
    """c = hash(a, b)"""

    r: ElementModQ
    """r = w + xc"""

    def is_valid(
        self,
        g: ElementModP,
        gx: ElementModP,
        h: ElementModP,
        hx: ElementModP,
        hash_header: ElementModQ = None,
        also_hash: List[Any] = None,
        check_c: bool = True,
    ) -> bool:
        """
        Checks that this Chaum-Pedersen proof certifies that the prover knew an x, such that (g, g^x) and (h, h^x)
        share the same exponent x, without revealing x. Part of the proof is a challenge constant. By suppressing
        this check, "fake" proofs can be validated. Useful when doing disjunctive proofs.
        :param g: See above.
        :param gx: See above.
        :param h: See above.
        :param hx: See above.
        :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q'). (default: None)
        :param also_hash: additional parameters (optional) to hash alongside everything else
        :param check_c: If False, the challenge constant is not verified. (default: True)
        :return: True if the proof is valid.
        """
        if also_hash is None:
            also_hash = []
        in_bounds_a = self.a.is_valid_residue()
        in_bounds_b = self.b.is_valid_residue()
        in_bounds_g = g.is_valid_residue()
        in_bounds_gx = gx.is_valid_residue()
        in_bounds_h = h.is_valid_residue()
        in_bounds_hx = hx.is_valid_residue()

        hash_good = (self.c == hash_elems(hash_header, self.a, self.b, *also_hash)) or (
            not check_c
        )

        agxc = mult_p(self.a, pow_p(gx, self.c))  # should yield g^{w + xc}
        gr = pow_p(g, self.r)  # should also yield g^{w + xc}

        good_g = agxc == gr

        bhxc = mult_p(self.b, pow_p(hx, self.c))
        hr = pow_p(h, self.r)

        good_h = bhxc == hr

        success = (
            hash_good
            and in_bounds_a
            and in_bounds_b
            and in_bounds_g
            and in_bounds_gx
            and in_bounds_h
            and in_bounds_hx
            and good_g
            and good_h
        )

        if not success:
            log_warning(
                "Invalid generic Chaum-Pedersen proof: "
                + str(
                    {
                        "hash_good": hash_good,
                        "in_bounds_a": in_bounds_a,
                        "in_bounds_b": in_bounds_b,
                        "in_bounds_g": in_bounds_g,
                        "in_bounds_gx": in_bounds_gx,
                        "in_bounds_h": in_bounds_h,
                        "in_bounds_hx": in_bounds_hx,
                        "good_g": good_g,
                        "good_h": good_h,
                    }
                )
            )
        return success


def make_chaum_pedersen_generic(
    g: ElementModP,
    h: ElementModP,
    x: ElementModQ,
    seed: ElementModQ,
    hash_header: ElementModQ = None,
    also_hash: List[Any] = None,
) -> GenericChaumPedersenProof:
    """
    Produces a generic Chaum-Pedersen proof that two tuples share an exponent, i.e., that
    for (g, g^x) and (h, h^x), it's the same value of x, but without revealing x. This
    generic proof can be used as a building-block for many other proofs.

    The seed is used for generating the random numbers used in the proof.

    There's no need for g^x and h^x in this particular computation.

    :param g: Any element in P that can be generated by `g_pow_p()`
    :param h: Any element in P that can be generated by `g_pow_p()`
    :param x: Any element in Q
    :param seed: Used to randomize the generation of the Chaum-Pedersen proof.
    :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
    :param also_hash: additional parameters (optional) to hash alongside everything else
    """

    if also_hash is None:
        also_hash = []

    w = Nonces(seed, "generic-chaum-pedersen-proof")[0]
    a = pow_p(g, w)
    b = pow_p(h, w)
    c = hash_elems(hash_header, a, b, *also_hash)
    r = a_plus_bc_q(w, x, c)

    return GenericChaumPedersenProof(a, b, c, r)


def make_fake_chaum_pedersen_generic(
    g: ElementModP,
    gx: ElementModP,
    h: ElementModP,
    hx: ElementModP,
    c: ElementModQ,
    seed: ElementModQ,
) -> GenericChaumPedersenProof:
    """
    Produces a generic "fake" Chaum-Pedersen proof that two tuples share an exponent, i.e., that
    for (g, g^x) and (h, h^x), it's the same value of x, but without revealing x. Unlike
    the regular Chaum-Pedersen proof, this version allows the challenge `c` to be specified,
    which allows everything to be faked. See the `is_valid` method on the resulting proof
    object. By default, the challenge is validated by hashing elements of the proof, which
    prevents these "fake" proofs from passing validation.

    The seed is used for generating the random numbers used in the proof.
    """

    r = Nonces(seed, "generic-chaum-pedersen-proof")[0]
    gr = pow_p(g, r)
    hr = pow_p(h, r)
    a = div_p(gr, pow_p(gx, c))
    b = div_p(hr, pow_p(hx, c))

    return GenericChaumPedersenProof(a, b, c, r)


class DisjunctiveChaumPedersenProofKnownNonce(NamedTuple):
    """
    Representation of a "disjunctive" Chaum-Pedersen (zero or one) proof.
    """

    proof0: GenericChaumPedersenProof
    proof1: GenericChaumPedersenProof
    c: ElementModQ

    def is_valid(
        self,
        ciphertext: ElGamalCiphertext,
        public_key: ElementModP,
        hash_header: ElementModQ,
    ) -> bool:
        """
        Validates a "disjunctive" Chaum-Pedersen (zero or one) proof.

        :param ciphertext: The ciphertext message
        :param public_key: The public key of the election
        :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
        :return: True if everything is consistent. False otherwise.
        """

        (alpha, beta) = ciphertext
        consistent_c = add_q(self.proof0.c, self.proof1.c) == self.c
        valid_hash = self.c == hash_elems(
            hash_header,
            alpha,
            beta,
            self.proof0.a,
            self.proof0.b,
            self.proof1.a,
            self.proof1.b,
        )

        valid0 = self.proof0.is_valid(
            g=G_MOD_P,
            gx=ciphertext.pad,
            h=public_key,
            hx=ciphertext.data,
            check_c=False,
        )

        valid1 = self.proof1.is_valid(
            g=G_MOD_P,
            gx=ciphertext.pad,
            h=public_key,
            hx=div_p(ciphertext.data, G_MOD_P),
            check_c=False,
        )

        # If valid0 or valid1 is false, this will already have been logged,
        # so we don't have to repeat it here.

        if not consistent_c or not valid_hash:
            log_warning(
                "Invalid commitments for disjunctive Chaum-Pedersen proof: "
                + str(
                    {
                        "consistent_c": consistent_c,
                        "valid_hash": valid_hash,
                        "valid0": valid0,
                        "valid1": valid1,
                    }
                )
            )

        return valid0 and valid1 and consistent_c and valid_hash


class ConstantChaumPedersenProofKnownNonce(NamedTuple):
    """
    Representation of a constant Chaum-Pedersen proof, produced
    with knowledge of the encryption nonce.
    """

    proof: "GenericChaumPedersenProof"
    constant: int

    def is_valid(
        self,
        ciphertext: ElGamalCiphertext,
        public_key: ElementModP,
        hash_header: ElementModQ,
        expected_constant: int = None,
    ) -> bool:
        """
        Validates that this proof *proves* that the given message is an encryption of the constant.

        :param ciphertext: The ciphertext message
        :param public_key: The public key of the election
        :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
        :param expected_constant: Optional parameter. If present, the constant in the proof is validated against the expected plaintext.
        :return: True if everything is consistent. False otherwise.
        """
        constant_q = int_to_q(self.constant, "constant")
        if constant_q is None:
            log_warning("cannot validate a proof with an out-of-bounds constant")
            return False

        return self.proof.is_valid(
            g=G_MOD_P,
            gx=ciphertext.pad,
            h=public_key,
            hx=div_p(ciphertext.data, g_pow_p(constant_q)),
            also_hash=[ciphertext.pad, ciphertext.data],
            hash_header=hash_header,
            check_c=True,
        ) and (
            (expected_constant == self.constant)
            if expected_constant is not None
            else True
        )


def make_disjunctive_chaum_pedersen_known_nonce(
    ciphertext: ElGamalCiphertext,
    plaintext: int,
    nonce: ElementModQ,
    public_key: ElementModP,
    hash_header: ElementModQ,
    seed: ElementModQ,
) -> DisjunctiveChaumPedersenProofKnownNonce:
    """
    Produce a "disjunctive" proof that an encryption of a given plaintext is either an encrypted zero or one.

    :param ciphertext: An ElGamal ciphertext
    :param plaintext: Zero or one
    :param nonce: The nonce used creating the ElGamal ciphertext
    :param public_key: The ElGamal public key for the election
    :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
    :param seed: Used to generate other random values here
    """

    assert (
        0 <= plaintext <= 1
    ), "make_disjunctive_chaum_pedersen only supports plaintexts of 0 or 1"
    if plaintext == 0:
        alpha, beta = ciphertext
        c1, v1, u0 = Nonces(seed, "disjoint-chaum-pedersen-proof")[0:3]
        a0 = g_pow_p(u0)
        b0 = pow_p(public_key, u0)
        neg_c1 = negate_q(c1)
        a1 = mult_p(g_pow_p(v1), pow_p(alpha, neg_c1))
        b1 = mult_p(pow_p(public_key, v1), g_pow_p(c1), pow_p(beta, neg_c1))
        c = hash_elems(hash_header, alpha, beta, a0, b0, a1, b1)
        c0 = a_minus_b_q(c, c1)
        v0 = a_plus_bc_q(u0, c0, nonce)

        # Note that we can't really use make_chaum_pedersen_generic, because it assumes
        # that we're trying to make a "real" proof, and doesn't deal with the shared
        # hash computation. So we're instead doing comparable work here on our own.
        # We still get to take advantage of the is_valid method as part of validating
        # a disjunctive proof, so at least we get some code reuse there.

        real_zero_proof = GenericChaumPedersenProof(a0, b0, c0, v0)
        fake_one_proof = GenericChaumPedersenProof(a1, b1, c1, v1)

        return DisjunctiveChaumPedersenProofKnownNonce(
            real_zero_proof, fake_one_proof, c
        )
    else:
        alpha, beta = ciphertext
        c0, v0, u1 = Nonces(seed, "disjoint-chaum-pedersen-proof")[0:3]
        neg_c0 = negate_q(c0)
        a0 = mult_p(g_pow_p(v0), pow_p(alpha, neg_c0))
        b0 = mult_p(pow_p(public_key, v0), pow_p(beta, neg_c0))
        a1 = g_pow_p(u1)
        b1 = pow_p(public_key, u1)
        c = hash_elems(hash_header, alpha, beta, a0, b0, a1, b1)
        c1 = a_minus_b_q(c, c0)
        v1 = a_plus_bc_q(u1, c1, nonce)
        fake_zero_proof = GenericChaumPedersenProof(a0, b0, c0, v0)
        real_one_proof = GenericChaumPedersenProof(a1, b1, c1, v1)

        return DisjunctiveChaumPedersenProofKnownNonce(
            fake_zero_proof, real_one_proof, c
        )


def make_constant_chaum_pedersen_proof_known_nonce(
    ciphertext: ElGamalCiphertext,
    plaintext: int,
    nonce: ElementModQ,
    public_key: ElementModP,
    seed: ElementModQ,
    hash_header: ElementModQ,
) -> ConstantChaumPedersenProofKnownNonce:
    """
    Produces a proof that a given encryption corresponds to a specific total value.

    :param ciphertext: An ElGamal ciphertext
    :param plaintext: The plaintext constant value used to make the ElGamal ciphertext (L in the spec)
    :param nonce: The aggregate nonce used creating the ElGamal ciphertext
    :param public_key: The ElGamal public key for the election
    :param seed: Used to generate other random values here
    :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
    """
    return ConstantChaumPedersenProofKnownNonce(
        make_chaum_pedersen_generic(
            g=G_MOD_P,
            h=public_key,
            x=nonce,
            seed=seed,
            hash_header=hash_header,
            also_hash=[ciphertext.pad, ciphertext.data],
        ),
        plaintext,
    )


class ConstantChaumPedersenProofKnownSecretKey(NamedTuple):
    """
    Representation of a constant Chaum-Pedersen decryption proof (i.e., a proof that
    a plaintext value corresponds to an ElGamal ciphertext, produced by knowing
    the ElGamal secret key).
    """

    proof: GenericChaumPedersenProof
    constant: int

    def is_valid(
        self,
        ciphertext: ElGamalCiphertext,
        public_key: ElementModP,
        hash_header: ElementModQ = None,
        expected_constant: int = None,
    ) -> bool:
        """
        Checks that this proof validates that `plaintext` is the proper decryption of `ciphertext`.

        :param ciphertext: The ElGamal ciphertext we're validating.
        :param public_key: The ElGamal public key used for this election.
        :param hash_header: A value used when generating the challenge, usually the election extended base hash (Q')
        :param expected_constant: Optional parameter. If present, the constant in the proof is validated against the expected constant.
        :return: True if the proof is valid for the decryption.
        """

        plaintext_p = int_to_p(self.constant)
        if plaintext_p is None or plaintext_p != self.constant:
            log_warning("plaintext doesn't match the proof")
            return False

        g_exp_plaintext = g_pow_p(plaintext_p)
        blinder = div_p(ciphertext.data, g_exp_plaintext)

        expected_plaintext_valid = (
            (expected_constant == self.constant)
            if expected_constant is not None
            else True
        )

        valid_proof = (
            self.proof.is_valid(
                g=G_MOD_P,
                gx=public_key,
                h=ciphertext.pad,
                hx=blinder,
                hash_header=hash_header,
                check_c=True,
            )
            and expected_plaintext_valid
        )
        if not valid_proof:
            log_warning(
                "Invalid Chaum-Pedersen decryption proof: "
                + str(
                    {
                        "ciphertext": ciphertext,
                        "public_key": public_key,
                        "proof": self.proof,
                        "expected_plaintext_valid": expected_plaintext_valid,
                    }
                )
            )

        return valid_proof


def make_constant_chaum_pedersen_proof_known_secret_key(
    ciphertext: ElGamalCiphertext,
    plaintext: int,
    secret_key: ElementModQ,
    seed: ElementModQ,
    hash_header: ElementModQ = None,
) -> ConstantChaumPedersenProofKnownSecretKey:
    """
    Produces a proof that the caller knows the secret key corresponding to this ciphertext. Use the
    `is_valid` method on the resulting `ConstantChaumPedersenProofKnownSecretKey` to validate a given
    plaintext.

    The seed is used for generating the random numbers used in the proof.
    """
    return ConstantChaumPedersenProofKnownSecretKey(
        make_chaum_pedersen_generic(
            g=G_MOD_P,
            h=ciphertext.pad,
            x=secret_key,
            seed=seed,
            hash_header=hash_header,
        ),
        plaintext,
    )
